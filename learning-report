http://tldp.org/LDP/abs/html/这个网站是一个很详细的高级Shell脚本编程手册；它全面且系统地讲解了bash编程的语法、习惯用法。
《Advanced Bash-Scripting Guide》对我这种初学者来说非常实用，由浅入深，非常详细，也有很多具体的案例。接下来将介绍这本书的大致内容。
第一部分：介绍
  首先介绍shell编程的意义：把复杂的问题分解成简单的小问题，然后再把各部分功能组合起来解决复杂问题；其次介绍如何编写及运行shell程序。
  
第二部分：基础
  1.特殊字符：
    #(注释符)  ;(命令分隔符)  ;;(case语句分支的结束符)  .("点"命令[圆点],等同于source；或者文件名的组成部分；或者当前目录；或者匹配任意一个字符) 
    "(部分引用) '(完全引用) ,(逗号操作符)  \(转义符)  /(文件路径的分隔符) `(命令替换) :(空命令)  !(取反操作符)  *(通配符；或者算术操作符) 
    ?(测试操作符；或者通配符) $(变量替换;或者行的结尾)   ${}(参数替换) $*, $@(位置参数)  $?(保存退出码值) $$(进程ID变量) ()(命令组;或者数组初始化)
    {xxx,yyy,zzz,...}(扩展支持) {}(代码块) [ ](测试；或者数组元素；字符集的范围) [[ ]](测试) (())(整数扩展) > &> >& >> <(重定向)
    <<(重定向) <<<(重定向) <, >(ASCII比较) |(管道)  \<, \>(在 regular expression中的单词界线)  >|(强迫重定向) ||(或逻辑操作符) &(在后台运行作业)
    &&(与逻辑操作符)  -(选项, 前缀；或者用于stdin或stdout重定向的源或目的；或者先前的工作目录；或者负号或减号) =(等号)  +(加;或者选项)
    %(取模) ~(主目录)  ~+(当前工作目录)  ~-(先前工作目录)  =~(正则表达式匹配) ^(行首) 控制字符(更改终端行为或文本显示)
    空白(用做函数的分隔符,分隔命令或变量)  
    
  2.变量与参数介绍
    主要包括变量替换、变量赋值、无类型的Bash变量、特殊变量类型：
    1) 其中变量替换与赋值：VARIABLE=value；变量引用：$variable 或 {variable};
    2) Bash不以"类型"来区分变量；本质上来说，Bash变量是字符串，但是根据环境的不同，Bash允许变量有整数计算和比较，其决定因素是变量的值是不是只含有数字；
    3) 特殊变量类型包括：局部变量，环境变量和位置变量。

  3.引用
    1) 引用变量推荐使用双引号；除了前缀($)、后引符(`)和转义符(\)外，使用双引号会使shell不再解释引号中其它的特殊字符，如"$variable"表示一个变量；
    2) 单引号和双引号类似，但是在单引号内，除了字符'，每个特殊字符都只是字面的意思。因此，在单引号内的字符$的特殊意思无效了；
    3) 转义是引用单字符的方法：在单个字符前面的转义符(\)告诉shell不必特殊解释这个字符，只把它当成字面上的意思；
    4) 特殊的转义字符组合：\n(表示新行) \r(表示回车)  \t(表示水平的制表符)  \v(表示垂直的制表符)  \b(表示后退符) \a(表示“警告”（蜂鸣或是闪动）)
       \0xx(翻译成ASCII码为八进制0xx所表示的字符) \"(表示引号(")的字面意思)  \$(表示美元符（$）的字面意思) \\(表示反斜杠（\）的字面意思)
       
  4.退出及退出状态
    1) exit命令一般用于结束一个脚本，并返回一个值给父进程；
    2) 每一个命令都能返回一个退出状态,一个命令执行成功返回0，一个执行不成功的命令则返回一个非零值，此值通常可以被解释成一个对应的错误值；
    3) 脚本里的函数和脚本自身都会返回一个退出状态码,在脚本或函数里被执行的最后一个命令将决定退出状态码；
    4) exit nnn 命令将会返回shell一个nnn的退出状态码;
    5) $?变量保存了最后一个命令执行后的退出状态。

  5.测试
    1) 测试结构
      if/then结构 test测试命令 [...]测试命令 [[...]]测试命令 elif/then结构 ((...))结构
    2) 文件测试操作符
      -e(文件存在)  -a(文件存在)  -f(文件是一个普通文件(不是一个目录或是一个设备文件)) -s(文件大小不为零) -d(文件是一个目录) -b(文件是一个块设备)
      -c(文件是一个字符设备(键盘, 调制解调器, 声卡, 等等.)) -p(文件是一个管道) -h(文件是一个符号链接) -L(文件是一个符号链接) -S(文件是一个socket)
      -t(文件(描述符)与一个终端设备相关)  -r(文件是否可读 (指运行这个测试命令的用户的读权限)) -w(文件是否可写 (指运行这个测试命令的用户的读权限))
      -x(文件是否可执行 (指运行这个测试命令的用户的读权限))  -g(文件或目录的设置-组-ID(sgid)标记被设置)  -u(文件的设置-用户-ID(suid)标志被设置)
      -k(粘住位设置) -O(你是文件拥有者) -G(你所在组和文件的group-id相同)  -N(文件最后一次读后被修改)   f1 -nt f2(文件f1比f2新)
      f1 -ot f2(文件f1比f2旧)   f1 -ef f2(文件f1和f2 是相同文件的硬链接)    !("非") 
    3) 其他比较操作符
      i) 整数比较：-eq(等于 if [ "$a" -eq "$b" ])   -ne(不等于  if [ "$a" -ne "$b" ])    -gt(大于  if [ "$a" -gt "$b" ])  
                  -ge(大于等于  if [ "$a" -ge "$b" ])    -lt(小于  if [ "$a" -lt "$b" ])   -le(小于等于  if [ "$a" -le "$b" ])
                  <(小于(在双括号里使用) (("$a" < "$b")))   <=(小于等于(在双括号里使用)   (("$a" <= "$b")))
                  >(大于(在双括号里使用) (("$a" > "$b")))   >=(大于等于(在双括号里使用)   (("$a" >= "$b")))
      j) 字符串比较: =(等于    if [ "$a" = "$b" ])   ==(等于 if [ "$a" == "$b" ])    !=(不相等  if [ "$a" != "$b" ])
                    <(小于    if [[ "$a" < "$b" ]]  if [ "$a" \< "$b" ])    >(大于  if [[ "$a" > "$b" ]]  if [ "$a" \> "$b" ])
                    -z(字符串为"null"，即是指字符串长度为零)   -n(字符串不为"null"，即长度不为零)
      k)混合比较：-a(逻辑与   如果exp1和exp2都为真，则exp1 -a exp2返回真)    -o(逻辑或  只要exp1和exp2任何一个为真，则exp1 -o exp2 返回真)
    
    
    
    
    
    
    
    
    
    
    
    
  
